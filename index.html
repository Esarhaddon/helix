<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};
    const unclaimedProps = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getUnreplacedNames(template) {
      return [
        ...new Set(
          [...template.matchAll(/<\/([A-Z].*?)>/g)].map(
            ([_, componentName]) => componentName
          )
        ),
      ];
    }

    function getTagAttribute(tag, attribute) {
      const match = tag.match(new RegExp(`${attribute}="(.*)"`));
      if (match) {
        return match[1];
      }
    }

    function getElementAttributes(element) {
      return Object.fromEntries(
        element
          .getAttributeNames()
          .flatMap((attributeName) => [
            [attributeName, element.getAttribute(attributeName)],
          ])
      );
    }

    const counts = {};
    const unPrefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unPrefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    // Rules of hooks apply
    function signal(initialValue) {
      const instanceKey = currentInstanceKey;
      const instanceSignals = instances[instanceKey].signals;

      let signal = instanceSignals[currentInstanceSignalIndex];

      if (!signal) {
        const id = getId("signal");

        signal = {
          id,
          proxy: new Proxy(
            { value: initialValue },
            {
              get(target, prop) {
                if (prop === "id") {
                  return id;
                }

                if (prop === "toString") {
                  return () =>
                    `instances.${instanceKey}.signals[${instances[
                      instanceKey
                    ].signals.findIndex((signal) => signal.id === id)}].proxy`;
                }

                return target[prop];
              },

              set(target, prop, value) {
                target[prop] = value;

                if (prop === "value") {
                  eventTarget.dispatchEvent(
                    new CustomEvent("signalUpdate", {
                      detail: {
                        id,
                        value,
                      },
                    })
                  );
                }
              },
            }
          ),
        };

        instanceSignals.push(signal);
      }

      currentInstanceSignalIndex++;
      return signal.proxy;
    }

    function props(data) {
      const tmpId = getId("props");
      unclaimedProps[tmpId] = data;
      return `props="${tmpId}"`;
    }

    // Keys are required for children when the number of child components of a
    // certain type or the order of components might change
    function render(destination, component, props) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      const interpolatedChildren = (instances[
        destinationKey
      ].interpolatedChildren ??= destination.innerHTML);

      let html = component({
        ...props,
        children: interpolatedChildren,
      });

      const componentNames = getUnreplacedNames(html);
      componentNames.forEach((componentName) => {
        if (!components[componentName]) {
          const Component = class extends HTMLElement {
            constructor() {
              super();

              this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
            }

            connectedCallback() {
              const key = this.getAttribute("key") || getId("fwc");
              this.setAttribute("key", key);

              console.log(`[${componentName}.${key}] connected, rendering...`);

              currentInstanceSignalIndex = 0;
              currentInstanceKey = key;
              instances[key] ||= { signals: [], childKeys: {} };

              render(this, window[componentName], {
                ...getElementAttributes(this),
                ...instances[key].props,
              });

              eventTarget.addEventListener(
                "signalUpdate",
                this.handleSignalUpdate
              );
            }

            disconnectedCallback() {
              eventTarget.removeEventListener(
                "signalUpdate",
                this.handleSignalUpdate
              );
            }

            handleSignalUpdate({ detail: { id } }) {
              if (
                instances[this.getAttribute("key")].signals.some(
                  (signal) => signal.id === id
                )
              ) {
                currentInstanceKey = this.getAttribute("key");
                currentInstanceSignalIndex = 0;
                render(this, window[componentName], {
                  ...getElementAttributes(this),
                  ...instances[currentInstanceKey].props,
                });
              }
            }
          };

          customElements.define(snakeCase(componentName), Component);
          components[componentName] = {
            component: Component,
            defined: true,
          };
        }

        const countsByComponentName = {};
        const ogHtmlLength = html.length;

        // Walk through child component names, replace them with valid web
        // component names, track keys and props, and reset interpolated
        // children for each one since their parent is re-rendering
        [...html.matchAll(/<([A-Z][a-zA-Z0-9]*)(?:.|\n)*?>/g)].map(
          (match, i) => {
            const [tag, componentName] = match;
            countsByComponentName[componentName] ||= 0;
            countsByComponentName[componentName]++;

            const assignedKey = getTagAttribute(tag, "key");
            const tmpPropsId = getTagAttribute(tag, "props");

            const key =
              assignedKey ||
              (instances[destinationKey].childKeys[
                componentName + "_" + countsByComponentName[componentName]
              ] ||= getId("fwc"));

            if (tmpPropsId) {
              instances[key] ||= { signals: [], childKeys: {} };
              instances[key].props = unclaimedProps[tmpPropsId];
              delete unclaimedProps[tmpPropsId];
            }

            if (assignedKey) {
              return;
            }

            html = html
              .split("")
              .toSpliced(
                match.index - ogHtmlLength,
                tag.length,
                tag.split(componentName).join(`${componentName} key="${key}" `)
              )
              .join("");
          }
        );

        html = html.replaceAll(componentName, snakeCase(componentName));
      });

      Object.values(instances[destinationKey].childKeys).forEach((key) => {
        if (instances[key]) {
          instances[key].interpolatedChildren = undefined;
        }
      });

      destination.innerHTML = html;
    }

    function NestedComponent({ children }) {
      const count = signal(0);

      return `
        <div>${count.value}</div>
        <button onclick="${count}.value++">press me (nested)</button>
        ${count.value > 5 ? `<span>count is over 5!</span>` : ""}
        <div>
          some stuff that's even more nested:
          <div>${children}</div>
        </div>
      `;
    }

    function MyButton({ children }) {
      const count = signal(0);

      return `
        <div>${count.value}</div>
        <button onclick="${count}.value++">${children || "press me"}</button>
        <NestedComponent></NestedComponent>
      `;
    }

    function HelloWorld() {
      return `
        <div>hello world</div>
        <MyButton></MyButton>
      `;
    }

    function MyBadge({ text, logHello, subtitle }) {
      logHello();
      return `
        <div>badge text: ${text}</div>
        <div>${subtitle}</div>
      `;
    }

    function ChildrenTest() {
      const bigNumber = signal(1_000);

      return `
        <NestedComponent>
          <MyBadge
            subtitle="this is a subtitle"
            ${props({
              text: "hello world",
              logHello: () => {
                console.log("hello there!");
              },
            })}
          ></MyBadge>
          <button onclick="${bigNumber}.value--">${bigNumber.value}</button>
          This is a <strong>child</strong> of Nested\\Component
          <div style="border: 1px solid red">
            <MyButton></MyButton>
          </div>
        </NestedComponent>
      `;
    }

    function App() {
      return `
        <MyBadge
          subtitle="this is a subtitle"
          ${props({
            text: "hello world",
            logHello: () => {
              console.log("hello there!");
            },
          })}
        ></MyBadge>
        <div>greetings:</div>
        <!-- <HelloWorld></HelloWorld> -->
        <ChildrenTest></ChildrenTest>
        <HelloWorld></HelloWorld>
        <MyButton>Custom text</MyButton>
        <HelloWorld></HelloWorld>
        <NestedComponent>
          <MyBadge
            subtitle="this is a subtitle"
            ${props({
              text: "hello world",
              logHello: () => {
                console.log("hello there!");
              },
            })}
          ></MyBadge>
        </NestedComponent>
      `;
    }

    render(document.getElementById("root"), App);
  </script>
</html>
