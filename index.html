<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};
    const unclaimedProps = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    const counts = {};
    const unPrefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unPrefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getUnreplacedNames(template) {
      return [
        ...new Set(
          [...template.matchAll(/<\/([A-Z].*?)>/g)].map(
            ([_, componentName]) => componentName
          )
        ),
      ];
    }

    function getTagAttribute(tag, attribute) {
      const match = tag.match(new RegExp(`${attribute}="(.*)"`));
      if (match) {
        return match[1];
      }
    }

    function getElementAttributes(element) {
      return Object.fromEntries(
        element
          .getAttributeNames()
          .flatMap((attributeName) => [
            [attributeName, element.getAttribute(attributeName)],
          ])
      );
    }

    function register(componentName) {
      if (!components[componentName]) {
        const Component = class extends HTMLElement {
          constructor() {
            super();
            this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
          }
          connectedCallback() {
            const key = this.getAttribute("key") || getId("fwc");
            this.setAttribute("key", key);

            render(this, window[componentName]);

            eventTarget.addEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          disconnectedCallback() {
            eventTarget.removeEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          handleSignalUpdate({ detail: { id } }) {
            if (
              instances[this.getAttribute("key")].accessedSignals?.some(
                (signal) => signal.id === id
              )
            ) {
              render(this, window[componentName]);
            }
          }
        };

        customElements.define(snakeCase(componentName), Component);
        components[componentName] = {
          componentName,
          component: Component,
          registered: true,
        };
      }
    }

    function parseComponents(html) {
      let parsed = html;
      const ogHtmlLength = html.length;

      [...html.matchAll(/<([A-Z][a-zA-Z0-9]*)(?:.|\n)*?>/g)].map((match, i) => {
        const [tag, componentName] = match;
        register(componentName);

        parsed = html
          .split("")
          .toSpliced(
            match.index - ogHtmlLength,
            tag.length,
            tag
              .split(componentName)
              .join(`${componentName} key="HLX_COMPONENT_KEY" `)
          )
          .join("");

        parsed = parsed.replaceAll(componentName, snakeCase(componentName));
      });

      return parsed;
    }

    function getTemplateBuilder(key, defaultStrings, ...defaultChildren) {
      return (strings, ...children) => {
        const templateChildren = children.length ? children : defaultChildren;
        const fragments = (strings || defaultStrings).map((fragment) =>
          parseComponents(fragment)
        );

        return {
          key,
          template: fragments.reduce((result, fragment, i) => {
            if (!result.length) {
              return fragment;
            }

            return (
              result +
              (Array.isArray(templateChildren[i - 1])
                ? Array(templateChildren[i - 1].length)
                    .fill("HLX_SLOT")
                    .join("")
                : "HLX_SLOT") +
              fragment
            );
          }, ""),
          children: templateChildren.flatMap((child) => child),
        };
      };
    }

    function hlx(stringsOrConfig, ...children) {
      if (Array.isArray(stringsOrConfig)) {
        const strings = stringsOrConfig;
        return getTemplateBuilder(undefined, strings, ...children)();
      } else if (typeof stringsOrConfig === "string") {
        const key = stringsOrConfig;
        return getTemplateBuilder(key);
      } else {
        const config = stringsOrConfig;
        return getTemplateBuilder(config.key);
      }
    }

    function fillTemplate(node, key = "", parents = []) {
      const { template, children } = node;
      const matches = [...template.matchAll(/(HLX_SLOT)|(HLX_COMPONENT_KEY)/g)];

      let charIndex = 0;
      let slotIndex = 0;
      let assignedChildKeyCount = 0;
      let componentIndex = 0;

      node.key = currentInstanceKey + (key ? "-" + key : "");
      node.html = matches.length ? "" : node.template;

      matches.forEach((match) => {
        switch (match[0]) {
          case "HLX_SLOT":
            const assignedChildKey = node.children[slotIndex].key;
            if (assignedChildKey) {
              assignedChildKeyCount++;
            }

            const childKey =
              currentInstanceKey +
              "-" +
              (key ? key + "." : "") +
              (assignedChildKey || slotIndex - assignedChildKeyCount);

            node.html +=
              template.slice(charIndex, match.index) +
              `<fragment key="${childKey}">HLX_CHILD_${childKey}</fragment>`;
            charIndex = match.index + "HLX_SLOT".length;
            slotIndex++;

            break;
          case "HLX_COMPONENT_KEY":
            node.html +=
              template.slice(charIndex, match.index) +
              currentInstanceKey +
              "-" +
              (key ? key + "." : "") +
              componentIndex;
            charIndex = match.index + "HLX_COMPONENT_KEY".length;
            componentIndex++;
        }
      });

      if (matches.length) {
        node.html += template.slice(charIndex);
      }

      if (node.html) {
        parents.forEach(
          (parent) =>
            (parent.html = parent.html.replace(
              `HLX_CHILD_${currentInstanceKey + "-" + key}`,
              node.html
            ))
        );
      }

      assignedChildKeyCount = 0;
      children.forEach((child, i) => {
        const assignedChildKey = child.key;
        if (assignedChildKey) {
          assignedChildKeyCount++;
        }

        fillTemplate(
          child,
          (key ? key + "." : "") +
            (assignedChildKey || i - assignedChildKeyCount),
          [...parents, node]
        );
      });

      return node;
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    // Rules of hooks apply
    function signal(initialValue) {
      const instanceKey = currentInstanceKey;
      const instanceSignals = instances[instanceKey].signals;

      let signal = instanceSignals[currentInstanceSignalIndex];

      if (!signal) {
        const id = getId("signal");

        signal = {
          id,
          proxy: new Proxy(
            { value: initialValue },
            {
              get(target, prop) {
                if (prop === "id") {
                  return id;
                }

                if (prop === "toString") {
                  return () =>
                    `instances.${instanceKey}.signals[${instances[
                      instanceKey
                    ].signals.findIndex((signal) => signal.id === id)}].proxy`;
                }

                if (prop === "value" && currentInstanceKey) {
                  instances[currentInstanceKey].accessedSignals ||= [];
                  instances[currentInstanceKey].accessedSignals.push(signal);
                }

                return target[prop];
              },

              set(target, prop, value) {
                target[prop] = value;

                if (prop === "value") {
                  eventTarget.dispatchEvent(
                    new CustomEvent("signalUpdate", {
                      detail: {
                        id,
                        value,
                      },
                    })
                  );
                }
              },
            }
          ),
        };

        instanceSignals.push(signal);
      }

      currentInstanceSignalIndex++;
      return signal.proxy;
    }

    function props(data) {
      const tmpId = getId("props");
      unclaimedProps[tmpId] = data;
      return `props="${tmpId}"`;
    }

    function render(destination, component) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      currentInstanceSignalIndex = 0;
      currentInstanceKey = destinationKey;

      const results = fillTemplate(component());

      console.log(`[${component.name}.${destinationKey}]:`);
      console.log(results.html);
      console.log(JSON.stringify(results, null, 2));

      // TODO: do diffing here
      destination.innerHTML = results.html;

      currentInstanceKey = undefined;
    }

    function TestComponent() {
      return hlx`
        <div>
          ${("myKey", ["a", "b", "c"].map((item) => hlx({ key: item })`thing`))}
        </div>
      `;
    }

    function App() {
      return hlx`
        <div>${hlx("test key")`this is the first child`}</div>
        <TestComponent></TestComponent>
        <div>${hlx`this is the last child`}</div>
      `;
    }

    render(document.getElementById("root"), App);
  </script>
</html>
