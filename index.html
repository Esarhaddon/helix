<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getUnreplacedNames(template) {
      return [
        ...new Set(
          [...template.matchAll(/<\/([A-Z].*?)>/g)].map(
            ([_, componentName]) => componentName
          )
        ),
      ];
    }

    const counts = {};
    const unPrefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unPrefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    // Rules of hooks apply
    function signal(initialValue) {
      const instanceKey = currentInstanceKey;
      const instanceSignals = instances[instanceKey].signals;

      let signal = instanceSignals[currentInstanceSignalIndex];

      if (!signal) {
        const id = getId("signal");

        signal = {
          id,
          proxy: new Proxy(
            { value: initialValue },
            {
              get(target, prop) {
                if (prop === "id") {
                  return id;
                }

                if (prop === "toString") {
                  return () =>
                    `instances.${instanceKey}.signals[${instances[
                      instanceKey
                    ].signals.findIndex((signal) => signal.id === id)}].proxy`;
                }

                return target[prop];
              },

              set(target, prop, value) {
                target[prop] = value;

                if (prop === "value") {
                  eventTarget.dispatchEvent(
                    new CustomEvent("signalUpdate", {
                      detail: {
                        id,
                        value,
                      },
                    })
                  );
                }
              },
            }
          ),
        };

        instanceSignals.push(signal);
      }

      currentInstanceSignalIndex++;
      return signal.proxy;
    }

    // Keys are required for children when the number of child components of a
    // certain type or the order of components might change
    function render(component, destination) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      const interpolatedChildren = (instances[
        destinationKey
      ].interpolatedChildren ??= destination.innerHTML);

      let html = component({
        children: interpolatedChildren,
      });

      const componentNames = getUnreplacedNames(html);
      componentNames.forEach((componentName) => {
        if (!components[componentName]) {
          const Component = class extends HTMLElement {
            constructor() {
              super();

              this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
            }

            connectedCallback() {
              const key = this.getAttribute("key") || getId("fwc");
              this.setAttribute("key", key);

              console.log(`[${componentName}.${key}] connected, rendering...`);

              currentInstanceSignalIndex = 0;
              currentInstanceKey = key;
              instances[key] ||= { signals: [], childKeys: {} };
              render(window[componentName], this);

              eventTarget.addEventListener(
                "signalUpdate",
                this.handleSignalUpdate
              );
            }

            disconnectedCallback() {
              eventTarget.removeEventListener(
                "signalUpdate",
                this.handleSignalUpdate
              );
            }

            handleSignalUpdate({ detail: { id } }) {
              if (
                instances[this.getAttribute("key")].signals.some(
                  (signal) => signal.id === id
                )
              ) {
                currentInstanceKey = this.getAttribute("key");
                currentInstanceSignalIndex = 0;
                render(window[componentName], this);
              }
            }
          };

          customElements.define(snakeCase(componentName), Component);
          components[componentName] = {
            component: Component,
            defined: true,
          };
        }

        const countsByComponentName = {};
        const ogHtmlLength = html.length;

        // Walk through child component names, replace them with valid web
        // component names, track keys, and reset interpolated children for each
        // one since their parent is re-rendering
        [
          ...html.matchAll(
            /<([A-Z][a-zA-Z0-9]*)(?:(?:.|\n)*?key="(.*?)".*?)?(?:.|\n)*?>/g
          ),
        ].map((match, i) => {
          const [tag, componentName, assignedKey] = match;
          countsByComponentName[componentName] ||= 0;
          countsByComponentName[componentName]++;

          if (assignedKey) {
            return;
          }

          const key = (instances[destinationKey].childKeys[
            componentName + "_" + countsByComponentName[componentName]
          ] ||= getId("fwc"));

          html = html
            .split("")
            .toSpliced(
              match.index - ogHtmlLength,
              tag.length,
              tag.split(componentName).join(`${componentName} key="${key}" `)
            )
            .join("");
        });

        html = html.replaceAll(componentName, snakeCase(componentName));
      });

      Object.values(instances[destinationKey].childKeys).forEach((key) => {
        if (instances[key]) {
          instances[key].interpolatedChildren = undefined;
        }
      });

      destination.innerHTML = html;
    }

    function NestedComponent({ children }) {
      const count = signal(0);

      return `
        <div>${count.value}</div>
        <button onclick="${count}.value++">press me (nested)</button>
        ${count.value > 5 ? `<span>count is over 5!</span>` : ""}
        <div>
          some stuff that's even more nested:
          <div>${children}</div>
        </div>
      `;
    }

    function MyButton() {
      const count = signal(0);

      return `
        <div>${count.value}</div>
        <button onclick="${count}.value++">press me</button>
        <NestedComponent></NestedComponent>
      `;
    }

    function HelloWorld() {
      return `
        <div>hello world</div>
        <MyButton></MyButton>
      `;
    }

    function ChildrenTest() {
      const bigNumber = signal(1_000);

      return `
        <NestedComponent>
          <button onclick="${bigNumber}.value--">${bigNumber.value}</button>
          This is a <strong>child</strong> of Nested\\Component
          <div style="border: 1px solid red">
          <MyButton></MyButton>
          </div>
        </NestedComponent>
      `;
    }

    function App() {
      return `
        <div>greetings:</div>
        <!-- <HelloWorld></HelloWorld> -->
        <ChildrenTest></ChildrenTest>
        <HelloWorld></HelloWorld>
        <HelloWorld></HelloWorld>
      `;
    }

    render(App, document.getElementById("root"));
  </script>
</html>
