<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};
    const unclaimedProps = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    const counts = {};
    const unPrefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unPrefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getUnreplacedNames(template) {
      return [
        ...new Set(
          [...template.matchAll(/<\/([A-Z].*?)>/g)].map(
            ([_, componentName]) => componentName
          )
        ),
      ];
    }

    function getTagAttribute(tag, attribute) {
      const match = tag.match(new RegExp(`${attribute}="(.*)"`));
      if (match) {
        return match[1];
      }
    }

    function getElementAttributes(element) {
      return Object.fromEntries(
        element
          .getAttributeNames()
          .flatMap((attributeName) => [
            [attributeName, element.getAttribute(attributeName)],
          ])
      );
    }

    function register(componentName) {
      if (!components[componentName]) {
        const Component = class extends HTMLElement {
          constructor() {
            super();
            this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
          }
          connectedCallback() {
            const key = this.getAttribute("key") || getId("fwc");
            this.setAttribute("key", key);

            render(this, window[componentName]);

            eventTarget.addEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          disconnectedCallback() {
            eventTarget.removeEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          handleSignalUpdate({ detail: { id } }) {
            if (
              instances[this.getAttribute("key")].accessedSignals?.some(
                (signal) => signal.id === id
              )
            ) {
              render(this, window[componentName]);
            }
          }
        };

        customElements.define(snakeCase(componentName), Component);
        components[componentName] = {
          componentName,
          component: Component,
          registered: true,
        };
      }
    }

    function parseComponents(html) {
      let parsed = html;
      const ogHtmlLength = html.length;

      [...html.matchAll(/<([A-Z][a-zA-Z0-9]*)(?:.|\n)*?>/g)].map((match, i) => {
        const [tag, componentName] = match;
        register(componentName);

        parsed = html
          .split("")
          .toSpliced(
            match.index - ogHtmlLength,
            tag.length,
            tag
              .split(componentName)
              .join(`${componentName} key="FWC_COMPONENT_KEY" `)
          )
          .join("");

        parsed = parsed.replaceAll(componentName, snakeCase(componentName));
      });

      return parsed;
    }

    const html =
      (strings, ...children) =>
      () => {
        const fragments = strings.map((fragment) => parseComponents(fragment));

        return {
          template: fragments.reduce((result, fragment, i) => {
            if (!result.length) {
              return fragment;
            }

            return result + "FWC_SLOT" + fragment;
          }, ""),
          children: children.map((child) => child()),
        };
      };

    function fillTemplate(node, key = "", parents = []) {
      const { template, children } = node;
      const matches = [...template.matchAll(/(FWC_SLOT)|(FWC_COMPONENT_KEY)/g)];

      let charIndex = 0;
      let slotIndex = 0;
      let componentIndex = 0;

      node.key = currentInstanceKey + (key ? "-" + key : "");
      node.html = matches.length ? "" : node.template;

      matches.forEach((match) => {
        switch (match[0]) {
          case "FWC_SLOT":
            const childKey =
              currentInstanceKey + "-" + (key ? key + "." : "") + slotIndex;

            node.html +=
              template.slice(charIndex, match.index) +
              `<fragment key="${childKey}">FWC_CHILD_${childKey}</fragment>`;
            charIndex = match.index + "FWC_SLOT".length;
            slotIndex++;

            break;
          case "FWC_COMPONENT_KEY":
            node.html +=
              template.slice(charIndex, match.index) +
              currentInstanceKey +
              "-" +
              (key ? key + "." : "") +
              componentIndex;
            charIndex = match.index + "FWC_COMPONENT_KEY".length;
            componentIndex++;
        }
      });

      if (matches.length) {
        node.html += template.slice(charIndex);
      }

      if (node.html) {
        parents.forEach(
          (parent) =>
            (parent.html = parent.html.replace(
              `FWC_CHILD_${currentInstanceKey + "-" + key}`,
              node.html
            ))
        );
      }

      children.forEach((child, i) =>
        fillTemplate(child, (key ? key + "." : "") + i, [...parents, node])
      );

      return node;
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    // Rules of hooks apply
    function signal(initialValue) {
      const instanceKey = currentInstanceKey;
      const instanceSignals = instances[instanceKey].signals;

      let signal = instanceSignals[currentInstanceSignalIndex];

      if (!signal) {
        const id = getId("signal");

        signal = {
          id,
          proxy: new Proxy(
            { value: initialValue },
            {
              get(target, prop) {
                if (prop === "id") {
                  return id;
                }

                if (prop === "toString") {
                  return () =>
                    `instances.${instanceKey}.signals[${instances[
                      instanceKey
                    ].signals.findIndex((signal) => signal.id === id)}].proxy`;
                }

                if (prop === "value" && currentInstanceKey) {
                  instances[currentInstanceKey].accessedSignals ||= [];
                  instances[currentInstanceKey].accessedSignals.push(signal);
                }

                return target[prop];
              },

              set(target, prop, value) {
                target[prop] = value;

                if (prop === "value") {
                  eventTarget.dispatchEvent(
                    new CustomEvent("signalUpdate", {
                      detail: {
                        id,
                        value,
                      },
                    })
                  );
                }
              },
            }
          ),
        };

        instanceSignals.push(signal);
      }

      currentInstanceSignalIndex++;
      return signal.proxy;
    }

    function props(data) {
      const tmpId = getId("props");
      unclaimedProps[tmpId] = data;
      return `props="${tmpId}"`;
    }

    // Keys are required for children when the number of child components of a
    // certain type or the order of components might change
    function render(destination, component) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      currentInstanceSignalIndex = 0;
      currentInstanceKey = destinationKey;

      const results = fillTemplate(component()());

      console.log(`[${component.name}.${destinationKey}]:`);
      console.log(results.html);
      console.log(JSON.stringify(results, null, 2));

      // TODO: do diffing here
      destination.innerHTML = results.html;

      currentInstanceKey = undefined;
    }

    function TestComponent() {
      return html`
        <div>this is another test</div>
        ${html`<span>
          sort of annoying that this isn't an actual sibling
          ${html`<span>what happens here?</span>`}
        </span>`}
        ${html`<span>does this work?</span>`}
      `;
    }

    function App() {
      return html`
        <div>hello world</div>
        <TestComponent></TestComponent>
        ${html`<TestComponent></TestComponent>`}
        <div>something else</div>
        ${html`hello world again`}
        <span>something at the end</span>
      `;
    }

    render(document.getElementById("root"), App);
  </script>
</html>
