<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};
    const eventHandlers = {};
    const propsByNodeKey = {};
    const propsByParentNodeKey = {};
    const previousPropsByNodeKey = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    const counts = {};
    const unprefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unprefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    function isPrimitive(value) {
      return (
        typeof value === "string" ||
        typeof value === "number" ||
        value === undefined ||
        value === null
      );
    }

    function isNullishPrimitive(value) {
      return value === null || value === undefined;
    }

    function isObject(obj) {
      return Boolean(obj && typeof obj === "object" && !Array.isArray(obj));
    }

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getCustomElementName(componentName) {
      return "hlx-" + snakeCase(componentName);
    }

    function define(componentName) {
      if (!components[componentName]) {
        const Component = class extends HTMLElement {
          constructor() {
            super();
            this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
            this.handleDeepSignalUpdate =
              this.handleDeepSignalUpdate.bind(this);
            this.handlePropsChange = this.handlePropsChange.bind(this);
          }

          connectedCallback() {
            const key = this.getAttribute("key") || getId("fwc");
            this.setAttribute("key", key);

            _render(this, window[componentName]);

            eventTarget.addEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
            eventTarget.addEventListener(
              "deepSignalUpdate",
              this.handleDeepSignalUpdate
            );
            eventTarget.addEventListener("propsChange", this.handlePropsChange);
          }

          disconnectedCallback() {
            eventTarget.removeEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
            eventTarget.removeEventListener(
              "propsChange",
              this.handlePropsChange
            );
            eventTarget.removeEventListener(
              "deepSignalUpdate",
              this.handleDeepSignalUpdate
            );
          }

          handleSignalUpdate({ detail: { id } }) {
            if (
              instances[this.getAttribute("key")].accessedSignals?.some(
                (signal) => signal.id === id
              )
            ) {
              _render(this, window[componentName]);
            }
          }

          handleDeepSignalUpdate({ detail: { id, path } }) {
            if (
              instances[this.getAttribute("key")].signalAccess?.[id]?.includes(
                path
              )
            ) {
              _render(this, window[componentName]);
            }
          }

          handlePropsChange({ detail: { key } }) {
            if (key === this.getAttribute("key")) {
              _render(this, window[componentName]);
            }
          }
        };

        customElements.define(getCustomElementName(componentName), Component);
        components[componentName] = {
          componentName,
          component: Component,
          registered: true,
        };
      }
    }

    function parseComponents(html) {
      let parsed = html;
      const ogHtmlLength = html.length;
      const componentNames = [];

      [...html.matchAll(/<([A-Z][a-zA-Z0-9]*)[^>]*>/g)].forEach((match, i) => {
        const [tag, componentName] = match;
        define(componentName);
        componentNames.push(componentName);

        // TODO: tighten up the parsing

        parsed = parsed
          .split("")
          .toSpliced(
            match.index - ogHtmlLength,
            tag.length,
            tag
              .split(componentName)
              .join(
                !tag.includes(`key="`)
                  ? `${componentName} key="HLX_NODE_KEY" `
                  : componentName
              ) + (tag.endsWith("/>") ? `</${componentName}>` : "")
          )
          .join("");
      });

      componentNames.forEach((componentName) => {
        parsed = parsed.replaceAll(
          componentName,
          getCustomElementName(componentName)
        );
      });

      return parsed;
    }

    function getTemplateBuilder(key, defaultStrings, ...defaultChildren) {
      return (strings, ...children) => {
        const templateChildren = children.length ? children : defaultChildren;
        const fragments = strings || defaultStrings;

        const childNodes = templateChildren.flatMap((child, i) => {
          if (typeof child === "function") {
            return { handler: child };
          } else if (isPrimitive(child)) {
            return {
              primitive: true,
              // TODO: escape this
              html: isNullishPrimitive(child) ? "" : child.toString(),
            };
          } else {
            return child;
          }
        });

        return {
          key,
          template: parseComponents(
            fragments.reduce((result, fragment, i) => {
              if (i === 0) {
                return fragment;
              }

              // TODO: tighten up the parsing

              const lastTagStart = result
                .split("")
                .findLastIndex((char) => char === "<");

              if (
                lastTagStart >
                result.split("").findLastIndex((char) => char === ">")
              ) {
                const lastTagNameEnd =
                  lastTagStart +
                  result
                    .slice(lastTagStart)
                    .split("")
                    .findIndex((char) => char === " ");

                const isAttribute = result.endsWith("=");
                const isProps =
                  result.endsWith("...") && isObject(childNodes[i - 1]);

                if (isAttribute) {
                  const attributeName = result.slice(
                    result.split("").findLastIndex((char) => char === " ") + 1,
                    -1
                  );

                  childNodes[i - 1].attribute = true;
                  childNodes[i - 1].name = attributeName;
                } else if (isProps) {
                  childNodes[i - 1] = {
                    values: childNodes[i - 1],
                    isProps: true,
                  };
                }

                return (
                  (result.slice(lastTagStart).includes(`key="`)
                    ? result
                    : result.slice(0, lastTagNameEnd) +
                      ' key="HLX_NODE_KEY" ' +
                      result.slice(lastTagNameEnd)) +
                  (isAttribute ? '"HLX_ATTR"' : isProps ? "HLX_PROPS" : "") +
                  fragment
                );
              } else {
                return (
                  result +
                  (Array.isArray(templateChildren[i - 1])
                    ? Array(templateChildren[i - 1].length)
                        .fill("HLX_SLOT")
                        .join("")
                    : "HLX_SLOT") +
                  fragment
                );
              }
            }, "")
          ),
          props: childNodes.filter((child) => child.isProps),
          attributes: childNodes.filter((child) => child.attribute),
          children: childNodes.filter(
            (child) => !child.attribute && !child.isProps
          ),
        };
      };
    }

    function hlx(stringsOrConfig, ...children) {
      if (Array.isArray(stringsOrConfig)) {
        const strings = stringsOrConfig;
        return getTemplateBuilder(undefined, strings, ...children)();
      } else if (typeof stringsOrConfig === "string") {
        const key = stringsOrConfig;
        return getTemplateBuilder(key);
      } else {
        const config = stringsOrConfig;
        return getTemplateBuilder(config.key);
      }
    }

    function fillTemplate(node, key = "", parents = []) {
      const { primitive, attribute, template, children, attributes, props } =
        node;

      node.key = currentInstanceKey + (key ? "-" + key : "");

      let charIndex = 0;
      let slotIndex = 0;
      let nodeIndex = 0;
      let assignedChildKeyCount = 0;

      const matches = [
        ...template.matchAll(
          /(HLX_SLOT)|(HLX_NODE_KEY)|(HLX_ATTR)|(\.\.\.HLX_PROPS)/g
        ),
      ];

      const attributeKeys = [];
      const childKeys = [];
      const propsKeys = [];
      const prefixedBaseKey = currentInstanceKey + "-" + (key ? key + "." : "");

      node.html = matches.length ? "" : node.template;

      matches.forEach((match) => {
        switch (match[0]) {
          case "HLX_SLOT":
            // TODO: it's still possible for these to collide with the keys of
            // array items in other arrays at the same level in the tree
            const assignedChildKey = node.children[slotIndex].key
              ? "key-" + node.children[slotIndex].key
              : undefined;

            if (assignedChildKey) {
              assignedChildKeyCount++;
            }

            const unprefixedKey =
              (key ? key + "." : "") +
              "slot." +
              (assignedChildKey || slotIndex - assignedChildKeyCount);
            const prefixedKey = currentInstanceKey + "-" + unprefixedKey;

            childKeys.push(unprefixedKey);
            node.html +=
              template.slice(charIndex, match.index) +
              `<hlx.fragment key="${prefixedKey}">HLX_CHILD_${prefixedKey}</hlx.fragment>`;
            charIndex = match.index + "HLX_SLOT".length;
            slotIndex++;

            break;
          case "HLX_NODE_KEY":
            node.html +=
              template.slice(charIndex, match.index) +
              prefixedBaseKey +
              nodeIndex;
            charIndex = match.index + "HLX_NODE_KEY".length;
            nodeIndex++;

            break;
          case "HLX_ATTR":
            attributeKeys.push(prefixedBaseKey + (nodeIndex - 1));
            node.html +=
              template.slice(charIndex, match.index) +
              "HLX_ATTR_" +
              prefixedBaseKey +
              (nodeIndex - 1);
            charIndex = match.index + "HLX_ATTR".length;

            break;
          case "...HLX_PROPS":
            propsKeys.push(prefixedBaseKey + (nodeIndex - 1));
            node.html += template.slice(charIndex, match.index);
            charIndex = match.index + "...HLX_PROPS".length;

            break;
        }
      });

      if (matches.length) {
        node.html += template.slice(charIndex);
      }

      props.forEach((props, i) => {
        props.key = propsKeys[i];

        if (!propsByNodeKey[props.key]) {
          previousPropsByNodeKey[props.key] = props.values;
        }
        propsByNodeKey[props.key] = props.values;

        propsByParentNodeKey[currentInstanceKey] ||= {};
        propsByParentNodeKey[currentInstanceKey][props.key] = props.values;
      });

      attributes.forEach((attribute, i) => {
        attribute.key = attributeKeys[i];

        if (attribute.handler) {
          eventHandlers[`HLX_ATTR_${attribute.key}`] = attribute.handler;
          attribute.html = `(function (e){eventHandlers['HLX_ATTR_${attribute.key}'](e)})(event)`;
        }

        node.html = node.html.replace(
          "HLX_ATTR_" + attribute.key,
          attribute.html
        );
      });

      children.forEach((child, i) => {
        const unprefixedKey = childKeys[i];

        if (child.primitive) {
          child.key = currentInstanceKey + "-" + unprefixedKey;
          node.html = node.html.replace(`HLX_CHILD_${child.key}`, child.html);
        } else {
          fillTemplate(child, unprefixedKey, [...parents, node]);
        }
      });

      parents.forEach(
        (parent) =>
          (parent.html = parent.html.replace(
            `HLX_CHILD_${currentInstanceKey + "-" + key}`,
            node.html
          ))
      );

      return node;
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    function makeDeepSignalProxy(value, path, signalId) {
      const proxy = new Proxy(value, {
        get(target, prop) {
          if (prop === "_isProxy") {
            return true;
          }

          const result = target[prop];
          const resultPath = (path ? path + "." : "") + prop;

          if (currentInstanceKey) {
            instances[currentInstanceKey].signalAccess ||= {};
            instances[currentInstanceKey].signalAccess[signalId] ||= [];
            instances[currentInstanceKey].signalAccess[signalId].push(
              resultPath
            );
          }

          if (isPrimitive(result) || result._isProxy) {
            return result;
          } else {
            return makeDeepSignalProxy(result, resultPath, signalId);
          }
        },

        set(target, prop, value) {
          const shouldSendEvent = !(target[prop] === value);
          target[prop] = value;

          if (shouldSendEvent) {
            eventTarget.dispatchEvent(
              new CustomEvent("deepSignalUpdate", {
                detail: { id: signalId, path: (path ? path + "." : "") + prop },
              })
            );
          }
        },
      });

      return proxy;
    }

    function _signal(initialValue) {
      const id = getId("signal");

      return {
        id,
        proxy: makeDeepSignalProxy({ value: initialValue }, "", id),
      };
    }

    function createSignal(initialValue) {
      return _signal(initialValue).proxy;
    }

    // Some of the rules of hooks apply
    function useSignal(initialValue) {
      const instanceSignals = currentInstanceKey
        ? instances[currentInstanceKey].signals
        : undefined;

      let signal = instanceSignals?.[currentInstanceSignalIndex];

      if (!signal) {
        signal = _signal(initialValue);
        instanceSignals?.push(signal);
      }

      if (currentInstanceKey) {
        currentInstanceSignalIndex++;
      }

      return signal.proxy;
    }

    // TODO: handle arrays?
    function getDomMutations(prev, next, mutations = []) {
      const element = document.querySelector(`[key="${next.key}"]`);

      if (next.attribute && prev.html !== next.html) {
        element.setAttribute(next.name, next.html);

        // Keep the input's value *property* in sync with its value *attribute*
        if (
          element instanceof HTMLInputElement &&
          next.name === "value" &&
          element.value !== next.html
        ) {
          element.value = next.html;
        }
      } else if (!next.attribute && next.primitive && prev.html !== next.html) {
        mutations.push(() => {
          element.textContent = next.html;
        });
      } else if (prev.template !== next.template) {
        mutations.push(() => {
          element.innerHTML = next.html;
        });
      } else {
        next.children?.forEach((child, i) => {
          getDomMutations(prev?.children[i], child, mutations);
        });
        next.attributes?.forEach((attribute, i) => {
          getDomMutations(prev?.attributes[i], attribute, mutations);
        });
      }

      return mutations;
    }

    function _render(destination, component) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      if (!instances[destinationKey] && destination.innerHTML) {
        propsByNodeKey[destinationKey] ||= {};
        propsByNodeKey[destinationKey].children = destination.innerHTML;
      }

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      currentInstanceSignalIndex = 0;
      currentInstanceKey = destinationKey;
      const results = fillTemplate(component(propsByNodeKey[destinationKey]));

      if (instances[destinationKey].prevTemplate) {
        getDomMutations(
          instances[destinationKey].prevTemplate,
          results
        ).forEach((mutation) => mutation());

        Object.entries(propsByParentNodeKey[currentInstanceKey] || {}).forEach(
          ([nodeKey, props]) => {
            if (
              !Object.entries(props).every(
                ([propKey, value]) =>
                  previousPropsByNodeKey[nodeKey][propKey] === value
              )
            ) {
              eventTarget.dispatchEvent(
                new CustomEvent("propsChange", { detail: { key: nodeKey } })
              );
            }
            previousPropsByNodeKey[nodeKey] = props;
          }
        );
      } else {
        destination.innerHTML = results.html;
      }

      instances[destinationKey].prevTemplate = results;

      currentInstanceKey = undefined;
    }

    function render(root, application) {
      const destinationKey = root.getAttribute("key") || getId("hlx");
      root.setAttribute("key", destinationKey);

      // Re-render the root component when its signals are updated
      eventTarget.addEventListener("signalUpdate", ({ detail: { id } }) => {
        if (
          instances[destinationKey].accessedSignals.some(
            (signal) => signal.id === id
          )
        ) {
          _render(root, application);
        }
      });

      eventTarget.addEventListener(
        "deepSignalUpdate",
        ({ detail: { id, path } }) => {
          if (instances[destinationKey].signalAccess?.[id]?.includes(path)) {
            _render(root, application);
          }
        }
      );

      _render(root, application);
    }
  </script>
  <script src="input.js"></script>
  <script>
    function ArrayTest() {
      const formState = useSignal({});

      return hlx`${Array(1_000)
        .fill(null)
        .map(
          (_, index) => hlx(index.toString())`
            ${index > 0 ? hlx`<br/>` : ""}
            <Input ...${{ formState, index }} />
          `
        )}`;
    }

    const global = createSignal("");

    function Counter() {
      const count = useSignal(0);

      return hlx`
        <div>${count.value}</div>
        <button onclick=${() => count.value++}>↑</button>
        <button onclick=${() => count.value--}>↓</button>
        ${count.value > 5 ? hlx`<span>count is over 5!</span>` : ""}
        <div>global signal value: ${global.value}</div>
      `;
    }

    function Count({ count }) {
      return hlx`
        <div>
          The count is: ${count}
        </div>
      `;
    }

    function ChildrenTest({ children } = {}) {
      return hlx`
        <div>rendering children:</div>
        <div>
          ${children}
        </div>
      `;
    }

    function App() {
      const test = useSignal({ the: { count: 0 } });
      const formState = useSignal({});

      return hlx`
        <Count ...${{
          count: hlx`<span>${test.value.the.count}</span>`,
        }}
        />
        <button onclick=${() => test.value.the.count++}>inc</button>
        <Counter />
        <input
          placeholder="global value"
          value=${global.value}
          oninput=${(e) => (global.value = e.target.value)}
        />
        <ChildrenTest>
         ${new Array(4).fill(null).map(
           (_, index) => hlx(index.toString())`
             <div>
              <Input ...${{ formState, index }} />
             </div>
           `
         )}
        </ChildrenTest>
        <div>global signal test: ${global.value}</div>
        <p>array test:</p>
        <ArrayTest />
      `;
    }

    render(document.getElementById("root"), App);
  </script>
</html>
