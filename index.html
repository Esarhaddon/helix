<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div id="root"></div>
  </body>
  <script>
    const eventTarget = new EventTarget();
    const components = {};
    const instances = {};
    const unclaimedProps = {};
    const eventHandlers = {};

    let currentInstanceKey;
    let currentInstanceSignalIndex = 0;

    const counts = {};
    const unprefixed = Symbol();

    function getId(prefix) {
      const key = prefix || unprefixed;
      counts[key] ||= 0;

      return (prefix ? prefix + "_" : "") + ++counts[key];
    }

    function isPrimitive(value) {
      return (
        typeof value === "string" ||
        typeof value === "number" ||
        value === undefined ||
        value === null
      );
    }

    function isNullishPrimitive(value) {
      return value === null || value === undefined;
    }

    function snakeCase(str) {
      return str
        .split("")
        .flatMap((char, i) =>
          /[A-Z]/.test(char) && i !== 0 ? ["-", char] : char
        )
        .join("")
        .toLowerCase();
    }

    function getCustomElementName(componentName) {
      return "hlx-" + snakeCase(componentName);
    }

    function register(componentName) {
      if (!components[componentName]) {
        const Component = class extends HTMLElement {
          constructor() {
            super();
            this.handleSignalUpdate = this.handleSignalUpdate.bind(this);
          }

          connectedCallback() {
            const key = this.getAttribute("key") || getId("fwc");
            this.setAttribute("key", key);

            render(this, window[componentName], false);

            eventTarget.addEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          disconnectedCallback() {
            eventTarget.removeEventListener(
              "signalUpdate",
              this.handleSignalUpdate
            );
          }

          handleSignalUpdate({ detail: { id } }) {
            if (
              instances[this.getAttribute("key")].accessedSignals?.some(
                (signal) => signal.id === id
              )
            ) {
              render(this, window[componentName], false);
            }
          }
        };

        customElements.define(getCustomElementName(componentName), Component);
        components[componentName] = {
          componentName,
          component: Component,
          registered: true,
        };
      }
    }

    function parseComponents(html) {
      let parsed = html;
      const ogHtmlLength = html.length;
      const componentNames = [];

      [...html.matchAll(/<([A-Z][a-zA-Z0-9]*)[^>]*>?/g)].forEach((match, i) => {
        const [tag, componentName] = match;
        register(componentName);
        componentNames.push(componentName);

        // TODO: you'll need to use an actual parser to properly add keys to
        // nodes

        if (!tag.includes(`key="`)) {
          parsed = parsed
            .split("")
            .toSpliced(
              match.index - ogHtmlLength,
              tag.length,
              tag
                .split(componentName)
                .join(`${componentName} key="HLX_NODE_KEY" `) +
                (tag.endsWith("/>") ? `</${componentName}>` : "")
            )
            .join("");
        }
      });

      componentNames.forEach((componentName) => {
        parsed = parsed.replaceAll(
          componentName,
          getCustomElementName(componentName)
        );
      });

      return parsed;
    }

    function getTemplateBuilder(key, defaultStrings, ...defaultChildren) {
      return (strings, ...children) => {
        const templateChildren = children.length ? children : defaultChildren;
        const fragments = strings || defaultStrings;

        const childNodes = templateChildren.flatMap((child, i) => {
          if (typeof child === "function") {
            return { handler: child };
          } else if (isPrimitive(child)) {
            return {
              primitive: true,
              // TODO: escape this
              html: isNullishPrimitive(child) ? "" : child.toString(),
            };
          } else {
            return child;
          }
        });

        return {
          key,
          template: parseComponents(
            fragments.reduce((result, fragment, i) => {
              if (i === 0) {
                return fragment;
              }

              const attrIndexes = [];

              // TODO: you'll need to use an actual parser to properly add keys to
              // nodes
              const lastTagStart = result
                .split("")
                .findLastIndex((char) => char === "<");

              if (
                lastTagStart >
                result.split("").findLastIndex((char) => char === ">")
              ) {
                const lastTagNameEnd =
                  lastTagStart +
                  result
                    .slice(lastTagStart)
                    .split("")
                    .findIndex((char) => char === " ");
                const attributeDefiniationAt = result
                  .split("")
                  .findLastIndex((char) => char === "=");
                const attributeName = result.slice(
                  result
                    .slice(0, attributeDefiniationAt)
                    .split("")
                    .findLastIndex((char) => char === " ") + 1,
                  attributeDefiniationAt
                );

                childNodes[i - 1].attribute = true;
                childNodes[i - 1].name = attributeName;

                return (
                  (result.slice(lastTagStart).includes(`key="`)
                    ? result
                    : result.slice(0, lastTagNameEnd) +
                      ' key="HLX_NODE_KEY" ' +
                      result.slice(lastTagNameEnd)) +
                  '"HLX_ATTR"' +
                  fragment
                );
              } else {
                return (
                  result +
                  (Array.isArray(templateChildren[i - 1])
                    ? Array(templateChildren[i - 1].length)
                        .fill("HLX_SLOT")
                        .join("")
                    : "HLX_SLOT") +
                  fragment
                );
              }
            }, "")
          ),
          children: childNodes.filter((child) => !child.attribute),
          attributes: childNodes.filter((child) => child.attribute),
        };
      };
    }

    function hlx(stringsOrConfig, ...children) {
      if (Array.isArray(stringsOrConfig)) {
        const strings = stringsOrConfig;
        return getTemplateBuilder(undefined, strings, ...children)();
      } else if (typeof stringsOrConfig === "string") {
        const key = stringsOrConfig;
        return getTemplateBuilder(key);
      } else {
        const config = stringsOrConfig;
        return getTemplateBuilder(config.key);
      }
    }

    function fillTemplate(node, key = "", parents = []) {
      const { primitive, attribute, template, children, attributes } = node;

      node.key = currentInstanceKey + (key ? "-" + key : "");

      let charIndex = 0;
      let slotIndex = 0;
      let nodeIndex = 0;
      let assignedChildKeyCount = 0;

      const matches = [
        ...template.matchAll(/(HLX_SLOT)|(HLX_NODE_KEY)|(HLX_ATTR)/g),
      ];

      const attributeKeys = [];
      const childKeys = [];
      const prefixedBaseKey = currentInstanceKey + "-" + (key ? key + "." : "");

      node.html = matches.length ? "" : node.template;

      matches.forEach((match) => {
        switch (match[0]) {
          case "HLX_SLOT":
            const assignedChildKey = node.children[slotIndex].key;
            if (assignedChildKey) {
              assignedChildKeyCount++;
            }

            const unprefixedKey =
              (key ? key + "." : "") +
              "slot." +
              (assignedChildKey || slotIndex - assignedChildKeyCount);
            childKeys.push(unprefixedKey);

            const prefixedKey = currentInstanceKey + "-" + unprefixedKey;

            node.html +=
              template.slice(charIndex, match.index) +
              `<hlx.fragment key="${prefixedKey}">HLX_CHILD_${prefixedKey}</hlx.fragment>`;
            charIndex = match.index + "HLX_SLOT".length;
            slotIndex++;

            break;
          case "HLX_NODE_KEY":
            node.html +=
              template.slice(charIndex, match.index) +
              prefixedBaseKey +
              nodeIndex;
            charIndex = match.index + "HLX_NODE_KEY".length;
            nodeIndex++;

            break;
          case "HLX_ATTR":
            attributeKeys.push(prefixedBaseKey + (nodeIndex - 1));
            node.html +=
              template.slice(charIndex, match.index) +
              "HLX_ATTR_" +
              prefixedBaseKey +
              (nodeIndex - 1);
            charIndex = match.index + "HLX_ATTR".length;

            break;
        }
      });

      if (matches.length) {
        node.html += template.slice(charIndex);
      }

      attributes.forEach((attribute, i) => {
        attribute.key = attributeKeys[i];

        if (attribute.handler) {
          eventHandlers[`HLX_ATTR_${attribute.key}`] = attribute.handler;
          attribute.html = `(function (e){eventHandlers['HLX_ATTR_${attribute.key}'](e)})(event)`;
        }

        node.html = node.html.replace(
          "HLX_ATTR_" + attribute.key,
          attribute.html
        );
      });

      assignedChildKeyCount = 0;
      children.forEach((child, i) => {
        const unprefixedKey = childKeys[i];

        if (child.primitive) {
          child.key = currentInstanceKey + "-" + unprefixedKey;
          node.html = node.html.replace(`HLX_CHILD_${child.key}`, child.html);
        } else {
          fillTemplate(child, unprefixedKey, [...parents, node]);
        }
      });

      parents.forEach(
        (parent) =>
          (parent.html = parent.html.replace(
            `HLX_CHILD_${currentInstanceKey + "-" + key}`,
            node.html
          ))
      );

      return node;
    }

    let newSignals = [];
    let currentInstanceSignals = [];

    // Rules of hooks apply
    function signal(initialValue) {
      const instanceKey = currentInstanceKey;
      const instanceSignals = instances[instanceKey].signals;

      let signal = instanceSignals[currentInstanceSignalIndex];

      if (!signal) {
        const id = getId("signal");

        signal = {
          id,
          proxy: new Proxy(
            { value: initialValue },
            {
              get(target, prop) {
                if (prop === "id") {
                  return id;
                }

                if (prop === "toString") {
                  return () =>
                    `instances['${instanceKey}'].signals[${instances[
                      instanceKey
                    ].signals.findIndex((signal) => signal.id === id)}].proxy`;
                }

                if (prop === "value" && currentInstanceKey) {
                  instances[currentInstanceKey].accessedSignals ||= [];
                  instances[currentInstanceKey].accessedSignals.push(signal);
                }

                return target[prop];
              },

              set(target, prop, value) {
                target[prop] = value;

                if (prop === "value") {
                  eventTarget.dispatchEvent(
                    new CustomEvent("signalUpdate", {
                      detail: {
                        id,
                        value,
                      },
                    })
                  );
                }
              },
            }
          ),
        };

        instanceSignals.push(signal);
      }

      currentInstanceSignalIndex++;
      return signal.proxy;
    }

    let propsCount = 0;

    function props(data) {
      const tmpId = getId("props");
      unclaimedProps[tmpId] = data;
      return `${tmpId}`;
    }

    function render(destination, component, isInitialRoot = true) {
      const destinationKey = destination.getAttribute("key") || getId("fwc");
      destination.setAttribute("key", destinationKey);

      // Re-render the root component when its signals are updated
      if (isInitialRoot) {
        eventTarget.addEventListener("signalUpdate", ({ detail: { id } }) => {
          if (
            instances[destinationKey].accessedSignals.some(
              (signal) => signal.id === id
            )
          ) {
            render(destination, component, false);
          }
        });
      }

      instances[destinationKey] ||= {
        signals: [],
        childKeys: {},
      };

      currentInstanceSignalIndex = 0;
      currentInstanceKey = destinationKey;

      const propsId = destination.getAttribute("props");
      const props =
        instances[currentInstanceKey].props ||
        (propsId ? unclaimedProps[propsId] : {});
      instances[currentInstanceKey].props = props;
      delete unclaimedProps[propsId];

      const results = fillTemplate(component(props));

      if (instances[destinationKey].prevTemplate) {
        getDomMutations(
          instances[destinationKey].prevTemplate,
          results
        ).forEach((mutation) => mutation());
      } else {
        destination.innerHTML = results.html;
      }

      instances[destinationKey].prevTemplate = results;

      currentInstanceKey = undefined;
    }

    // TODO: handle arrays
    function getDomMutations(prev, next, mutations = []) {
      const element = document.querySelector(`[key="${next.key}"]`);

      if (next.attribute && prev.html !== next.html) {
        element.setAttribute(next.name, next.html);

        // Keep the input's value *property* in sync with its value *attribute*
        if (
          element instanceof HTMLInputElement &&
          next.name === "value" &&
          element.value !== next.html
        ) {
          element.value = next.html;
        }
      } else if (!next.attribute && next.primitive && prev.html !== next.html) {
        mutations.push(() => {
          element.textContent = next.html;
        });
      } else if (prev.template !== next.template) {
        mutations.push(() => {
          element.innerHTML = next.html;
        });
      } else {
        next.children?.forEach((child, i) => {
          getDomMutations(prev?.children[i], child, mutations);
        });
        next.attributes?.forEach((attribute, i) => {
          getDomMutations(prev?.attributes[i], attribute, mutations);
        });
      }

      return mutations;
    }
  </script>
  <script src="my-input.js"></script>
  <script>
    function ArrayTest() {
      const formState = signal({});

      return hlx`${Array(50)
        .fill(null)
        .map(
          (_, index) => hlx(index.toString())`
            <br/>
            <Input props=${props({ formState, index })} />`
        )}`;
    }

    function Counter() {
      const count = signal(0);

      return hlx`
        <div>${count.value}</div>
        <button onclick=${() => count.value++}>↑</button>
        <button onclick=${() => count.value--}>↓</button>
        ${count.value > 5 ? hlx`<span>count is over 5!</span>` : ""}
      `;
    }

    function App() {
      const test = signal(0);

      return hlx`
        <div>${test.value}</div>
        <button onclick=${() => test.value++}>inc</button>
        <Counter />
        <ArrayTest />
      `;
    }

    render(document.getElementById("root"), App);
  </script>
</html>
